# 服务治理入门

> 以下样例基于MacOS系统，IDEA的IDE进行演示，用其他系统或IDE的同学请参照样例并酌情调整。

服务治理时一个非常宽泛的概念，对于**SEMAK**框架而言，主要是围绕对微服务之间的调用、配置管理，以及服务可靠性的保障来展开。

本节基于 [基础入门](基础入门.md) 章节进行扩展，依然承接之前DEMO项目进行展开，但一些**基础步骤**将不再重复阐述。



## 1. 服务注册与发现

服务注册与发现主要解耦了服务之间的依赖细节（IP，端口等），实现对微服务状态和数据的动态管理。



### 1.1. 准备

1. 已搭建好的 **Alibaba Nacos** 集群服务（**Nacos**版本尽量与框架依赖的客户端版本匹配）。

2. 如果没有通过 [项目生成平台](../准备/项目生成.md) 勾选**服务治理**相关模块的话，我们需要将下面的Maven坐标依赖到`demo-support`模块的POM文件中：

   ```xml
   <dependency>
      <groupId>com.github.semak.rest</groupId>
      <artifactId>semak-rest-spring-cloud-alibaba-starter</artifactId>
      <version>最新RELEASE版本</version>
   </dependency>
   ```

   

### 1.2. 服务注册

**服务注册**旨在将服务以**唯一服务名**的方式发布到一个**中心化**的服务上，让需要调用此服务的**客户端**可以通过**唯一服务名**找到它，并读取它的元数据（构成服务的地址列表，服务状态等）来进行访问。

编辑`application-dev.yml`用户配置文件，加入**Nacos**注册端配置

```yaml
spring:
  ...
  cloud:
    nacos:
      discovery:
        server-addr: 192.168.1.234:22048
```

* 将**Nacos**服务地址指定到 **server-addr** 属性上。

* 启动应用后，我们可以看到`demo`服务已经以应用名`github.demo`注册到**Nacos**服务上。

  ![image-20211115134729729](.assets/image-20211115134729729.png)
  
  点击 `详情` 操作后，从服务详情页面中，我们可以看到已注册服务节点的详细信息：
  
  ![image-20211115134903070](.assets/image-20211115134903070.png)
  
  再看一下模拟集群部署时的节点效果：
  
  ![image-20211115135418004](.assets/image-20211115135418004.png)
  
  ![image-20211115135502714](.assets/image-20211115135502714.png)



### 1.3. 服务发现

作为一个服务调用方，我们可以利用 [服务方生成的Facade客户端代理](基础入门#_47-生成facade客户端代理（可选）) 类库来**无感知**地访问服务端。

开始之前，我们依然使用**基础入门**中的`demo-invoker`项目来模拟对`demo`项目发布的服务进行调用。

同服务注册一样，我们需要将下面的Maven坐标依赖到`demo-support`模块的POM文件中

```xml
<dependency>
   <groupId>com.github.semak.rest</groupId>
   <artifactId>semak-rest-spring-cloud-alibaba-starter</artifactId>
   <version>最新RELEASE版本</version>
</dependency>
```

服务方生成的Facade客户端代理类库的Maven坐标依赖到`demo-integration`模块的POM文件中

```xml
<dependency>
  <groupId>com.github</groupId>
  <artifactId>demo-facade</artifactId>
  <version>1.0.0-SNAPSHOT</version>
</dependency>
```

编辑`application-dev.yml`用户配置文件，加入**Nacos**调用端配置

```yaml
spring:
  ...
  cloud:
    nacos:
      discovery:
        server-addr: 192.168.1.234:22048
```

同服务端一样，我们甚至不需要配置多余的配置（**listOfServers**这些配置将不再需要），仅仅需要将客户端指向**Nacos**服务即可。

进入`demo-invoker-test/demo-invoker-test-integration`模块，沿用原测试案例（基础入门中定义的测试案例）进行远程服务的调用。

```java
package com.github.demo.invoker.integration;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

/**
* Integration Test Configuration
*
* @author caobin
* @version 1.0 2021.10.20
*/
@Configuration
@EnableAutoConfiguration
@ComponentScan(basePackages = {
        "com.github.demo.invoker.integration"
})
public class IntegrationTestConfiguration {
}
```

```java
package com.github.demo.invoker.integration.cases;

import com.github.demo.domain.dto.UserFetchResponse;
import com.github.demo.invoker.integration.IntegrationTestConfiguration;
import com.github.demo.invoker.integration.UserManager;
import lombok.extern.slf4j.Slf4j;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.junit4.SpringRunner;

/**
 * UserManagerTestcase
 *
 * @author caobin
 * @version 1.0
 * @date 2021.10.21
 */
@Slf4j
@RunWith(SpringRunner.class)
@SpringBootTest(classes = IntegrationTestConfiguration.class, webEnvironment = SpringBootTest.WebEnvironment.NONE)
@ActiveProfiles("dev")
public class UserManagerTestcase {

    @Autowired
    private UserManager userManager;

    @Test
    public void fetchOne() {
        UserFetchResponse userFetchResponse = userManager.fetchOneUser("GeorgeZod");
        Assert.assertNotNull(userFetchResponse);
        log.info(">>> Received response: {}", userFetchResponse);
    }
}
```

执行结果：

`demo-invoker`控制台输出：

![image-20211115145702202](.assets/image-20211115145702202.png)

`demo`控制台输出：

![image-20211115145806906](.assets/image-20211115145806906.png)

至此，一个完整的服务注册和发现流程就完成了。我们可以看到，有服务治理功能的加持后，不仅中心化管理更为便捷，开发配置也更为简洁。



## 2. 动态配置

在系统开发过程中，开发者通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成。配置变更是调整系统运行时的行为的有效手段。













## 3. 服务保护

为什么会有服务保护这样一个功能？简单来说，随着业务流量与复杂性增加，微服务部署的增多，大致会产生这样两种情况：

1. 微服务节点流量或突发流量压力增大，而节点处理能力有限导致了服务响应缓慢或不可用情况。

2. 服务链路变长，某个链路上的服务单元如果出了故障，故障在链路调用中会产生放大的效果，导致整条链路的阻塞，继而演变为整体系统的瘫痪。

为解决这两种情况，会分别提供以下两种解决方案：

1. **流量控制**：其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。
2. **熔断降级**：暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。



### 3.1. 准备

1. 已搭建好的 **Alibaba Nacos** 集群服务。

2. 如果没有通过 [项目生成平台](../准备/项目生成.md) 勾选**服务治理**相关模块的话，我们需要将下面的Maven坐标依赖到`demo-support`模块的POM文件中：

   ```xml
   <dependency>
      <groupId>com.github.semak.rest</groupId>
      <artifactId>semak-rest-spring-cloud-alibaba-starter</artifactId>
      <version>最新RELEASE版本</version>
   </dependency>
   ```

   

